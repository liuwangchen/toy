// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.2.2

package pb

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	async "github.com/liuwangchen/toy/pkg/async"
	middleware "github.com/liuwangchen/toy/transport/middleware"
	httprpc "github.com/liuwangchen/toy/transport/rpc/httprpc"
	binding "github.com/liuwangchen/toy/transport/rpc/httprpc/binding"
	reflect "reflect"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the goctopus package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL
var _ = reflect.TypeOf

const _ = httprpc.SupportPackageIsVersion1

var _ = middleware.Chain()
var _ = new(async.Async)

type GreeterHTTPServer interface {
	MultiSayHelloStream(context.Context, *HelloRequest, *MultiSayHelloServerStream) error
	SayHello(ctx context.Context, req *HelloRequest) (*HelloReply, error)
}

func RegisterGreeterHTTPServer(conn *httprpc.ServerConn, srv GreeterHTTPServer, opts ...httprpc.ServiceOption) {
	r := conn.Route("/")
	opt := new(httprpc.ServiceOpt)
	for _, o := range opts {
		o(opt)
	}
	r.POST("/helloworld.Greeter/SayHello", _Greeter_SayHello0_HTTP_Handler(srv, opt))
	r.POST("/helloworld.Greeter/MultiSayHello", _Greeter_MultiSayHello0_HTTP_Handler(srv, opt))
}

func _Greeter_SayHello0_HTTP_Handler(srv GreeterHTTPServer, opt *httprpc.ServiceOpt) func(ctx httprpc.Context) error {
	return func(ctx httprpc.Context) error {
		var in HelloRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		httprpc.SetOperation(ctx, "/helloworld.Greeter/SayHello")
		h := ctx.Middleware(middleware.Chain(opt.Mw...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SayHello(ctx, req.(*HelloRequest))
		}))
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*HelloReply)
		return ctx.Result(200, reply)
	}
}

type MultiSayHelloServerStream struct {
	httprpc.IServerStream
}

func NewMultiSayHelloServerStream(stream httprpc.IServerStream) *MultiSayHelloServerStream {
	return &MultiSayHelloServerStream{IServerStream: stream}
}

func (st *MultiSayHelloServerStream) Send(v *HelloReply) error {
	return st.SendMsg(v)
}

func _Greeter_MultiSayHello0_HTTP_Handler(srv GreeterHTTPServer, opt *httprpc.ServiceOpt) func(ctx httprpc.Context) error {
	return func(ctx httprpc.Context) error {
		var in HelloRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		httprpc.SetOperation(ctx, "/helloworld.Greeter/MultiSayHello")
		stream := NewMultiSayHelloServerStream(httprpc.NewHttpServerStream(ctx.Response(), httprpc.CodecForRequest(ctx.Request(), "Accept")))
		h := ctx.Middleware(middleware.Chain(opt.Mw...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			err := srv.MultiSayHelloStream(ctx, req.(*HelloRequest), stream)
			if err != nil {
				return nil, err
			}
			return nil, nil
		}))
		_, err := h(ctx, &in)
		return err
	}
}

type GreeterHTTPClient interface {
	MultiSayHelloStream(ctx context.Context, req *HelloRequest, opts ...httprpc.CallOption) (st *MultiSayHelloClientStream, err error)
	SayHello(ctx context.Context, req *HelloRequest, opts ...httprpc.CallOption) (rsp *HelloReply, err error)
}

type GreeterHTTPClientImpl struct {
	cc *httprpc.ClientConn
}

func NewGreeterHTTPClient(conn *httprpc.ClientConn) GreeterHTTPClient {
	return &GreeterHTTPClientImpl{conn}
}

type MultiSayHelloClientStream struct {
	recver httprpc.IClientStream
}

func NewMultiSayHelloClientStream(recver httprpc.IClientStream) *MultiSayHelloClientStream {
	return &MultiSayHelloClientStream{recver: recver}
}

func (s *MultiSayHelloClientStream) Recv() (*HelloReply, error) {
	v := new(HelloReply)
	err := s.recver.RecvMsg(v)
	if v == nil {
		return nil, err
	}
	return v, err
}

func (c *GreeterHTTPClientImpl) MultiSayHelloStream(ctx context.Context, in *HelloRequest, opts ...httprpc.CallOption) (*MultiSayHelloClientStream, error) {
	pattern := "/helloworld.Greeter/MultiSayHello"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, httprpc.Operation("/helloworld.Greeter/MultiSayHello"))
	opts = append(opts, httprpc.PathTemplate(pattern))
	stream, err := c.cc.Stream(ctx, "POST", path, in, opts...)
	if err != nil {
		return nil, err
	}
	return NewMultiSayHelloClientStream(stream), err
}

func (c *GreeterHTTPClientImpl) SayHello(ctx context.Context, in *HelloRequest, opts ...httprpc.CallOption) (*HelloReply, error) {
	var out HelloReply
	pattern := "/helloworld.Greeter/SayHello"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, httprpc.Operation("/helloworld.Greeter/SayHello"))
	opts = append(opts, httprpc.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

type PusherHTTPServer interface {
	Push(context.Context, *PushNotify) error
}

func RegisterPusherHTTPServer(conn *httprpc.ServerConn, srv PusherHTTPServer, opts ...httprpc.ServiceOption) {
	r := conn.Route("/")
	opt := new(httprpc.ServiceOpt)
	for _, o := range opts {
		o(opt)
	}
	r.POST("/helloworld.Pusher/Push", _Pusher_Push0_HTTP_Handler(srv, opt))
}

func _Pusher_Push0_HTTP_Handler(srv PusherHTTPServer, opt *httprpc.ServiceOpt) func(ctx httprpc.Context) error {
	return func(ctx httprpc.Context) error {
		var in PushNotify
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		httprpc.SetOperation(ctx, "/helloworld.Pusher/Push")
		h := ctx.Middleware(middleware.Chain(opt.Mw...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return nil, srv.Push(ctx, req.(*PushNotify))
		}))
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out
		return ctx.Result(200, reply)
	}
}

type PusherHTTPClient interface {
	Push(ctx context.Context, req *PushNotify, opts ...httprpc.CallOption) error
}

type PusherHTTPClientImpl struct {
	cc *httprpc.ClientConn
}

func NewPusherHTTPClient(conn *httprpc.ClientConn) PusherHTTPClient {
	return &PusherHTTPClientImpl{conn}
}

func (c *PusherHTTPClientImpl) Push(ctx context.Context, in *PushNotify, opts ...httprpc.CallOption) error {
	var out empty.Empty
	pattern := "/helloworld.Pusher/Push"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, httprpc.Operation("/helloworld.Pusher/Push"))
	opts = append(opts, httprpc.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return err
	}
	return err
}
